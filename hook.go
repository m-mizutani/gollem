package gollem

import "context"

type (
	// LoopHook is a hook for the session loop. This hook is called at the beginning of each iteration
	// in the main execution loop, before sending input to the LLM.
	//
	// Parameters:
	// - loop: The current loop count (0-indexed)
	// - input: The current input that will be sent to the LLM (user messages, tool responses, etc.)
	//
	// This hook is useful for:
	// - Monitoring session progress and loop iterations
	// - Debugging conversation flow and input content
	// - Implementing custom loop limits or conditions
	// - Logging conversation state at each iteration
	//
	// If the hook returns an error, the entire session loop will be aborted immediately.
	//
	// Example usage:
	//   gollem.WithLoopHook(func(ctx context.Context, loop int, input []gollem.Input) error {
	//       log.Printf("Loop %d: Processing %d inputs", loop, len(input))
	//       if loop > 50 {
	//           return errors.New("custom loop limit exceeded")
	//       }
	//       return nil
	//   })
	LoopHook func(ctx context.Context, loop int, input []Input) error

	// MessageHook is a hook for text messages generated by the LLM. This hook is called whenever
	// the LLM generates text content (not including function calls).
	//
	// Parameters:
	// - msg: The text message generated by the LLM
	//
	// This hook is useful for:
	// - Displaying LLM responses to users in real-time
	// - Recording conversation transcripts
	// - Implementing custom message filtering or processing
	// - Streaming responses to external systems
	//
	// Note: This hook is called for each text chunk in streaming mode, and once per response
	// in blocking mode. Function call responses do not trigger this hook.
	// If the hook returns an error, the execution will be aborted immediately.
	//
	// Example usage:
	//   gollem.WithMessageHook(func(ctx context.Context, msg string) error {
	//       fmt.Print(msg) // Stream to console
	//       return nil
	//   })
	MessageHook func(ctx context.Context, msg string) error

	// ToolRequestHook is a hook for tool execution requests. This hook is called just before
	// executing any tool, regardless of whether the tool exists or not.
	//
	// Parameters:
	// - tool: The function call details including name, arguments, and ID
	//
	// This hook is useful for:
	// - Logging tool usage and parameters
	// - Implementing access control for specific tools
	// - Monitoring tool execution patterns
	// - Debugging tool call issues
	//
	// Note: This hook is called even for unknown/missing tools, allowing you to handle
	// or log such cases. Facilitator tool calls do not trigger this hook.
	// If the hook returns an error, the execution will be aborted immediately.
	//
	// Example usage:
	//   gollem.WithToolRequestHook(func(ctx context.Context, tool gollem.FunctionCall) error {
	//       log.Printf("Executing tool: %s with args: %v", tool.Name, tool.Arguments)
	//       return nil
	//   })
	ToolRequestHook func(ctx context.Context, tool FunctionCall) error

	// ToolResponseHook is a hook for successful tool execution responses. This hook is called
	// after a tool executes successfully and returns a result.
	//
	// Parameters:
	// - tool: The function call details that was executed
	// - response: The result returned by the tool execution
	//
	// This hook is useful for:
	// - Logging tool execution results
	// - Post-processing tool responses
	// - Implementing custom result validation
	// - Recording tool performance metrics
	//
	// Note: This hook is only called for successful tool executions. Failed executions
	// trigger ToolErrorHook instead. Facilitator tool responses do not trigger this hook.
	// If the hook returns an error, the execution will be aborted immediately.
	//
	// Example usage:
	//   gollem.WithToolResponseHook(func(ctx context.Context, tool gollem.FunctionCall, response map[string]any) error {
	//       log.Printf("Tool %s completed with result: %v", tool.Name, response)
	//       return nil
	//   })
	ToolResponseHook func(ctx context.Context, tool FunctionCall, response map[string]any) error

	// ToolErrorHook is a hook for tool execution errors. This hook is called when a tool
	// execution fails and returns an error.
	//
	// Parameters:
	// - err: The error returned by the tool execution
	// - tool: The function call details that failed to execute
	//
	// This hook is useful for:
	// - Logging and monitoring tool execution failures
	// - Implementing custom error handling strategies
	// - Recording tool reliability metrics
	// - Sending error notifications to external systems
	//
	// Note: This hook is called for all tool execution errors except ErrExitConversation,
	// which is handled specially by the system. The hook can return an error to abort
	// the entire execution, or return nil to continue with the error handling.
	// To stop execution on specific errors, return the same error from the hook.
	//
	// Example usage:
	//   gollem.WithToolErrorHook(func(ctx context.Context, err error, tool gollem.FunctionCall) error {
	//       log.Printf("Tool %s failed: %v", tool.Name, err)
	//       if isCriticalError(err) {
	//           return err // Abort execution
	//       }
	//       return nil // Continue with normal error handling
	//   })
	ToolErrorHook func(ctx context.Context, err error, tool FunctionCall) error

	// CompactionHook is a hook for history compaction events. This hook is called when
	// the history is compacted to reduce memory usage and token count.
	//
	// Parameters:
	// - original: The original history before compaction
	// - compacted: The compacted history after compaction
	//
	// This hook is useful for:
	// - Monitoring compaction efficiency and frequency
	// - Logging compaction events for debugging
	// - Recording compaction metrics for performance analysis
	// - Implementing custom post-compaction logic
	//
	// If the hook returns an error, the compaction will still succeed but the error
	// will be logged as a warning.
	//
	// Example usage:
	//   gollem.WithCompactionHook(func(ctx context.Context, original, compacted *gollem.History) error {
	//       ratio := float64(compacted.ToCount()) / float64(original.ToCount())
	//       log.Printf("History compacted: %d -> %d messages (%.2f%% reduction)",
	//           original.ToCount(), compacted.ToCount(), (1-ratio)*100)
	//       return nil
	//   })
	CompactionHook func(ctx context.Context, original, compacted *History) error
)

// defaultLoopHook is the default implementation of LoopHook that does nothing.
// This is used when no custom LoopHook is provided.
func defaultLoopHook(ctx context.Context, loop int, input []Input) error {
	return nil
}

// defaultMessageHook is the default implementation of MessageHook that does nothing.
// This is used when no custom MessageHook is provided.
func defaultMessageHook(ctx context.Context, msg string) error {
	return nil
}

// defaultToolRequestHook is the default implementation of ToolRequestHook that does nothing.
// This is used when no custom ToolRequestHook is provided.
func defaultToolRequestHook(ctx context.Context, tool FunctionCall) error {
	return nil
}

// defaultToolResponseHook is the default implementation of ToolResponseHook that does nothing.
// This is used when no custom ToolResponseHook is provided.
func defaultToolResponseHook(ctx context.Context, tool FunctionCall, response map[string]any) error {
	return nil
}

// defaultToolErrorHook is the default implementation of ToolErrorHook that does nothing.
// This is used when no custom ToolErrorHook is provided.
func defaultToolErrorHook(ctx context.Context, err error, tool FunctionCall) error {
	return nil
}

// defaultCompactionHook is the default implementation of CompactionHook that does nothing.
// This is used when no custom CompactionHook is provided.
func defaultCompactionHook(ctx context.Context, original, compacted *History) error {
	return nil
}
