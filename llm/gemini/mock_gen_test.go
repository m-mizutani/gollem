// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gemini_test

import (
	"context"
	"github.com/m-mizutani/gollem/llm/gemini"
	genai "google.golang.org/genai"
	"sync"
)

// apiClientMock is a mock implementation of gemini.apiClient.
//
//	func TestSomethingThatUsesapiClient(t *testing.T) {
//
//		// make and configure a mocked gemini.apiClient
//		mockedapiClient := &apiClientMock{
//			CountTokensFunc: func(ctx context.Context, model string, contents []*genai.Content, config *genai.CountTokensConfig) (*genai.CountTokensResponse, error) {
//				panic("mock out the CountTokens method")
//			},
//			GenerateContentFunc: func(ctx context.Context, model string, contents []*genai.Content, config *genai.GenerateContentConfig) (*genai.GenerateContentResponse, error) {
//				panic("mock out the GenerateContent method")
//			},
//			GenerateContentStreamFunc: func(ctx context.Context, model string, contents []*genai.Content, config *genai.GenerateContentConfig) <-chan gemini.StreamResponse {
//				panic("mock out the GenerateContentStream method")
//			},
//		}
//
//		// use mockedapiClient in code that requires gemini.apiClient
//		// and then make assertions.
//
//	}
type apiClientMock struct {
	// CountTokensFunc mocks the CountTokens method.
	CountTokensFunc func(ctx context.Context, model string, contents []*genai.Content, config *genai.CountTokensConfig) (*genai.CountTokensResponse, error)

	// GenerateContentFunc mocks the GenerateContent method.
	GenerateContentFunc func(ctx context.Context, model string, contents []*genai.Content, config *genai.GenerateContentConfig) (*genai.GenerateContentResponse, error)

	// GenerateContentStreamFunc mocks the GenerateContentStream method.
	GenerateContentStreamFunc func(ctx context.Context, model string, contents []*genai.Content, config *genai.GenerateContentConfig) <-chan gemini.StreamResponse

	// calls tracks calls to the methods.
	calls struct {
		// CountTokens holds details about calls to the CountTokens method.
		CountTokens []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Model is the model argument value.
			Model string
			// Contents is the contents argument value.
			Contents []*genai.Content
			// Config is the config argument value.
			Config *genai.CountTokensConfig
		}
		// GenerateContent holds details about calls to the GenerateContent method.
		GenerateContent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Model is the model argument value.
			Model string
			// Contents is the contents argument value.
			Contents []*genai.Content
			// Config is the config argument value.
			Config *genai.GenerateContentConfig
		}
		// GenerateContentStream holds details about calls to the GenerateContentStream method.
		GenerateContentStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Model is the model argument value.
			Model string
			// Contents is the contents argument value.
			Contents []*genai.Content
			// Config is the config argument value.
			Config *genai.GenerateContentConfig
		}
	}
	lockCountTokens           sync.RWMutex
	lockGenerateContent       sync.RWMutex
	lockGenerateContentStream sync.RWMutex
}

// CountTokens calls CountTokensFunc.
func (mock *apiClientMock) CountTokens(ctx context.Context, model string, contents []*genai.Content, config *genai.CountTokensConfig) (*genai.CountTokensResponse, error) {
	if mock.CountTokensFunc == nil {
		panic("apiClientMock.CountTokensFunc: method is nil but apiClient.CountTokens was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Model    string
		Contents []*genai.Content
		Config   *genai.CountTokensConfig
	}{
		Ctx:      ctx,
		Model:    model,
		Contents: contents,
		Config:   config,
	}
	mock.lockCountTokens.Lock()
	mock.calls.CountTokens = append(mock.calls.CountTokens, callInfo)
	mock.lockCountTokens.Unlock()
	return mock.CountTokensFunc(ctx, model, contents, config)
}

// CountTokensCalls gets all the calls that were made to CountTokens.
// Check the length with:
//
//	len(mockedapiClient.CountTokensCalls())
func (mock *apiClientMock) CountTokensCalls() []struct {
	Ctx      context.Context
	Model    string
	Contents []*genai.Content
	Config   *genai.CountTokensConfig
} {
	var calls []struct {
		Ctx      context.Context
		Model    string
		Contents []*genai.Content
		Config   *genai.CountTokensConfig
	}
	mock.lockCountTokens.RLock()
	calls = mock.calls.CountTokens
	mock.lockCountTokens.RUnlock()
	return calls
}

// GenerateContent calls GenerateContentFunc.
func (mock *apiClientMock) GenerateContent(ctx context.Context, model string, contents []*genai.Content, config *genai.GenerateContentConfig) (*genai.GenerateContentResponse, error) {
	if mock.GenerateContentFunc == nil {
		panic("apiClientMock.GenerateContentFunc: method is nil but apiClient.GenerateContent was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Model    string
		Contents []*genai.Content
		Config   *genai.GenerateContentConfig
	}{
		Ctx:      ctx,
		Model:    model,
		Contents: contents,
		Config:   config,
	}
	mock.lockGenerateContent.Lock()
	mock.calls.GenerateContent = append(mock.calls.GenerateContent, callInfo)
	mock.lockGenerateContent.Unlock()
	return mock.GenerateContentFunc(ctx, model, contents, config)
}

// GenerateContentCalls gets all the calls that were made to GenerateContent.
// Check the length with:
//
//	len(mockedapiClient.GenerateContentCalls())
func (mock *apiClientMock) GenerateContentCalls() []struct {
	Ctx      context.Context
	Model    string
	Contents []*genai.Content
	Config   *genai.GenerateContentConfig
} {
	var calls []struct {
		Ctx      context.Context
		Model    string
		Contents []*genai.Content
		Config   *genai.GenerateContentConfig
	}
	mock.lockGenerateContent.RLock()
	calls = mock.calls.GenerateContent
	mock.lockGenerateContent.RUnlock()
	return calls
}

// GenerateContentStream calls GenerateContentStreamFunc.
func (mock *apiClientMock) GenerateContentStream(ctx context.Context, model string, contents []*genai.Content, config *genai.GenerateContentConfig) <-chan gemini.StreamResponse {
	if mock.GenerateContentStreamFunc == nil {
		panic("apiClientMock.GenerateContentStreamFunc: method is nil but apiClient.GenerateContentStream was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Model    string
		Contents []*genai.Content
		Config   *genai.GenerateContentConfig
	}{
		Ctx:      ctx,
		Model:    model,
		Contents: contents,
		Config:   config,
	}
	mock.lockGenerateContentStream.Lock()
	mock.calls.GenerateContentStream = append(mock.calls.GenerateContentStream, callInfo)
	mock.lockGenerateContentStream.Unlock()
	return mock.GenerateContentStreamFunc(ctx, model, contents, config)
}

// GenerateContentStreamCalls gets all the calls that were made to GenerateContentStream.
// Check the length with:
//
//	len(mockedapiClient.GenerateContentStreamCalls())
func (mock *apiClientMock) GenerateContentStreamCalls() []struct {
	Ctx      context.Context
	Model    string
	Contents []*genai.Content
	Config   *genai.GenerateContentConfig
} {
	var calls []struct {
		Ctx      context.Context
		Model    string
		Contents []*genai.Content
		Config   *genai.GenerateContentConfig
	}
	mock.lockGenerateContentStream.RLock()
	calls = mock.calls.GenerateContentStream
	mock.lockGenerateContentStream.RUnlock()
	return calls
}
