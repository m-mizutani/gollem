// Package compacter provides middleware for automatic conversation history compaction
// when token limit errors are detected. It uses LLM to summarize old messages.
package compacter

import (
	"context"
	"encoding/json"
	"log/slog"

	"github.com/m-mizutani/goerr/v2"
	"github.com/m-mizutani/gollem"
)

// DefaultSummaryPrompt is the default prompt used for summarizing conversation history
var DefaultSummaryPrompt = `Please summarize the above conversation history concisely while preserving all important information, context, and key details. The summary will be used to continue the conversation.

Provide a clear and comprehensive summary that captures the essence of the conversation.`

const (
	defaultCompactRatio = 0.7
	defaultMaxRetries   = 3
)

// CompactionEvent contains information about a compaction event.
//
// The compaction process selects messages from the beginning of the conversation history
// based on the configured compact ratio (default 70%). These messages are summarized using
// an LLM and replaced with a single summary message.
//
// Data sizes represent character counts:
//   - OriginalDataSize: Total character count of all original messages
//   - CompactedDataSize: Total character count after compaction (summary + remaining messages)
//
// Token usage represents the actual LLM token consumption during summarization:
//   - InputTokens: Number of tokens sent to LLM for summarization
//   - OutputTokens: Number of tokens generated by LLM for the summary
//
// The compact ratio determines what percentage of the original data size should be compressed.
// For example, with a 70% ratio and 1000 total characters, the first 700 characters worth of
// messages from the beginning will be summarized into a single message.
type CompactionEvent struct {
	OriginalDataSize  int    // Total character count before compaction
	CompactedDataSize int    // Total character count after compaction (summary + remaining)
	InputTokens       int    // LLM input tokens used for summarization
	OutputTokens      int    // LLM output tokens generated for summary
	Summary           string // The generated summary text
	Attempt           int    // Retry attempt number (1-based)
}

// CompactionHook is a function called when compaction occurs
type CompactionHook func(ctx context.Context, event *CompactionEvent)

type config struct {
	llmClient     gollem.LLMClient
	compactRatio  float64
	summaryPrompt string
	maxRetries    int
	logger        *slog.Logger
	onCompaction  CompactionHook
}

// Option is a configuration option for the compacter middleware
type Option func(*config)

// WithMaxRetries sets the maximum number of retry attempts (default: 3)
func WithMaxRetries(maxRetries int) Option {
	return func(c *config) {
		c.maxRetries = maxRetries
	}
}

// WithLogger sets the logger for compaction events
func WithLogger(logger *slog.Logger) Option {
	return func(c *config) {
		c.logger = logger
	}
}

// WithCompactRatio sets the ratio of history to compact (default: 0.7)
// The ratio should be between 0.0 and 1.0
func WithCompactRatio(ratio float64) Option {
	return func(c *config) {
		c.compactRatio = ratio
	}
}

// WithSummaryPrompt sets a custom prompt for summarization
// Use %s placeholder for conversation history text
func WithSummaryPrompt(prompt string) Option {
	return func(c *config) {
		c.summaryPrompt = prompt
	}
}

// WithCompactionHook sets a callback function that is called when compaction occurs
func WithCompactionHook(hook CompactionHook) Option {
	return func(c *config) {
		c.onCompaction = hook
	}
}

// newConfig creates a new config with default values
func newConfig(llmClient gollem.LLMClient, options ...Option) *config {
	cfg := &config{
		llmClient:     llmClient,
		compactRatio:  defaultCompactRatio,
		summaryPrompt: DefaultSummaryPrompt,
		maxRetries:    defaultMaxRetries,
		logger:        slog.New(slog.DiscardHandler),
	}

	for _, opt := range options {
		opt(cfg)
	}

	return cfg
}

// retryWithCompaction attempts to compact history and retry the request
// Returns the last error if all retries fail
func retryWithCompaction(
	ctx context.Context,
	req *gollem.ContentRequest,
	cfg *config,
	initialErr error,
	retry func(context.Context, *gollem.ContentRequest) error,
) error {
	cfg.logger.Info("token limit exceeded, attempting compaction")

	lastErr := initialErr
	for attempt := 1; attempt <= cfg.maxRetries; attempt++ {
		cfg.logger.Info("compaction attempt", "attempt", attempt, "max_retries", cfg.maxRetries)

		// Compact the history
		if req.History == nil || len(req.History.Messages) == 0 {
			cfg.logger.Warn("no history to compact")
			return lastErr
		}

		compactedHistory, compactErr := compactHistory(
			ctx,
			req.History,
			cfg,
			attempt,
		)
		if compactErr != nil {
			cfg.logger.Error("compaction failed", "error", compactErr)
			return goerr.Wrap(compactErr, "failed to compact history")
		}

		// Update request history
		req.History = compactedHistory

		// Retry the request
		cfg.logger.Info("retrying after compaction", "attempt", attempt)
		lastErr = retry(ctx, req)

		// If successful or different error, return
		if lastErr == nil || !goerr.HasTag(lastErr, gollem.ErrTagTokenExceeded) {
			return lastErr
		}

		cfg.logger.Info("still token limit exceeded after compaction", "attempt", attempt)
	}

	cfg.logger.Warn("max retries reached", "max_retries", cfg.maxRetries)
	return lastErr
}

// NewContentBlockMiddleware creates a middleware that automatically compacts history
// using LLM when ErrTagTokenExceeded is detected
func NewContentBlockMiddleware(llmClient gollem.LLMClient, options ...Option) gollem.ContentBlockMiddleware {
	cfg := newConfig(llmClient, options...)

	return func(next gollem.ContentBlockHandler) gollem.ContentBlockHandler {
		return func(ctx context.Context, req *gollem.ContentRequest) (*gollem.ContentResponse, error) {
			resp, err := next(ctx, req)

			// Check if error has ErrTagTokenExceeded tag
			if err != nil && goerr.HasTag(err, gollem.ErrTagTokenExceeded) {
				var retryResp *gollem.ContentResponse
				retryErr := retryWithCompaction(ctx, req, cfg, err, func(ctx context.Context, req *gollem.ContentRequest) error {
					var innerErr error
					retryResp, innerErr = next(ctx, req)
					return innerErr
				})
				return retryResp, retryErr
			}

			return resp, err
		}
	}
}

// NewContentStreamMiddleware creates a streaming middleware that automatically compacts history
// using LLM when ErrTagTokenExceeded is detected
func NewContentStreamMiddleware(llmClient gollem.LLMClient, options ...Option) gollem.ContentStreamMiddleware {
	cfg := newConfig(llmClient, options...)

	return func(next gollem.ContentStreamHandler) gollem.ContentStreamHandler {
		return func(ctx context.Context, req *gollem.ContentRequest) (<-chan *gollem.ContentResponse, error) {
			respChan, err := next(ctx, req)

			// Check if error has ErrTagTokenExceeded tag
			if err != nil && goerr.HasTag(err, gollem.ErrTagTokenExceeded) {
				var retryChan <-chan *gollem.ContentResponse
				retryErr := retryWithCompaction(ctx, req, cfg, err, func(ctx context.Context, req *gollem.ContentRequest) error {
					var innerErr error
					retryChan, innerErr = next(ctx, req)
					return innerErr
				})
				return retryChan, retryErr
			}

			return respChan, err
		}
	}
}

// compactHistory compresses the history using LLM summarization
func compactHistory(
	ctx context.Context,
	history *gollem.History,
	cfg *config,
	attempt int,
) (*gollem.History, error) {
	if history == nil || len(history.Messages) == 0 {
		return nil, goerr.New("history is empty")
	}

	// Calculate total character count
	totalChars := countMessageChars(history.Messages)
	compactChars := int(float64(totalChars) * cfg.compactRatio)

	cfg.logger.Info("compacting history with LLM",
		"messages_before", len(history.Messages),
		"total_chars", totalChars,
		"compact_chars", compactChars,
		"compact_ratio", cfg.compactRatio,
	)

	// Extract messages to compact
	messagesToCompact, remainingMessages := extractMessagesToCompact(history.Messages, compactChars)

	if len(messagesToCompact) == 0 {
		cfg.logger.Warn("no messages to compact")
		return history, nil
	}

	cfg.logger.Info("generating summary", "messages_to_summarize", len(messagesToCompact))

	// Create history with messages to compact
	compactHistory := &gollem.History{
		LLType:   history.LLType,
		Version:  history.Version,
		Messages: messagesToCompact,
	}

	// Generate summary using LLM with history
	session, err := cfg.llmClient.NewSession(ctx,
		gollem.WithSessionHistory(compactHistory),
	)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create LLM session for summarization")
	}

	resp, err := session.GenerateContent(ctx, gollem.Text(cfg.summaryPrompt))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to generate summary")
	}

	if len(resp.Texts) == 0 {
		return nil, goerr.New("summary generation returned no text")
	}

	summary := resp.Texts[0]

	cfg.logger.Info("compaction completed",
		"messages_after", len(remainingMessages)+1,
		"summary_length", len(summary),
	)

	// Call hook if configured
	if cfg.onCompaction != nil {
		remainingChars := countMessageChars(remainingMessages)
		event := &CompactionEvent{
			OriginalDataSize:  totalChars,
			CompactedDataSize: len(summary) + remainingChars,
			InputTokens:       resp.InputToken,
			OutputTokens:      resp.OutputToken,
			Summary:           summary,
			Attempt:           attempt,
		}
		cfg.onCompaction(ctx, event)
	}

	// Create new history with summary as first message
	summaryContent, err := gollem.NewTextContent(summary)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create summary content")
	}

	// Determine summary role to maintain user/assistant alternation
	// If next message is from assistant, summary should be from user, and vice-versa
	// Default to assistant since the LLM generated the summary
	summaryRole := gollem.RoleAssistant
	if len(remainingMessages) > 0 && remainingMessages[0].Role == gollem.RoleAssistant {
		summaryRole = gollem.RoleUser
	}

	summaryMessage := gollem.Message{
		Role:     summaryRole,
		Contents: []gollem.MessageContent{summaryContent},
	}

	// Build new history
	newMessages := make([]gollem.Message, 0, len(remainingMessages)+1)
	newMessages = append(newMessages, summaryMessage)
	newMessages = append(newMessages, remainingMessages...)

	return &gollem.History{
		LLType:   history.LLType,
		Version:  history.Version,
		Messages: newMessages,
	}, nil
}

// countMessageChars calculates the total character count of all messages
func countMessageChars(messages []gollem.Message) int {
	totalChars := 0
	for _, msg := range messages {
		for _, content := range msg.Contents {
			// Unmarshal content data to get text
			var textData struct {
				Text string `json:"text"`
			}
			if err := json.Unmarshal(content.Data, &textData); err != nil {
				continue
			}

			totalChars += len(textData.Text)
		}
	}
	return totalChars
}

// extractMessagesToCompact extracts messages from the beginning until targetChars is reached
// Returns (messagesToCompact, remainingMessages)
func extractMessagesToCompact(messages []gollem.Message, targetChars int) ([]gollem.Message, []gollem.Message) {
	if len(messages) == 0 {
		return nil, nil
	}

	currentChars := 0
	splitIndex := 0

	for i, msg := range messages {
		msgChars := 0
		for _, content := range msg.Contents {
			var textData struct {
				Text string `json:"text"`
			}
			if err := json.Unmarshal(content.Data, &textData); err != nil {
				continue
			}

			msgChars += len(textData.Text)
		}

		currentChars += msgChars

		if currentChars >= targetChars {
			splitIndex = i + 1
			break
		}
	}

	// If we didn't find enough chars (target exceeds total), don't compact anything
	if splitIndex == 0 {
		return nil, messages
	}

	// Ensure at least one message remains
	if splitIndex >= len(messages) {
		splitIndex = len(messages) - 1
	}

	return messages[:splitIndex], messages[splitIndex:]
}
